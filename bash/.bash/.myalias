DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" 1> /dev/null && pwd )"

# Git alias
alias mga="git add"
alias mgau="git add -u"
alias mgaa="git add -A"
alias mgb="git branch"
alias mgbr="git branch -r"
alias mgc="git commit"
alias mgcz="git cz"
alias mgcm="git commit -m"
alias mgcl="git clean"
alias mgco="git checkout"
alias mgcod="git checkout develop"
alias mgcom="git checkout main"
alias mgcob="git checkout -b"
alias mgcp="git cherry-pick"
alias mgd="git diff"
alias mgdd="git diff develop"
alias mgdm="git diff main"
alias mgdh="git diff HEAD"
alias mgf="git fetch"
alias mgfp="git fetch -p"
alias mgfa="git fetch --all"
alias mgl="git log --graph --pretty=format:'%Cred%h -%C(yellow)%d%Creset %s %Cgreen(%cI) %C(bold blue)<%an>%Creset' --abbrev-commit"
alias mglm="git log --graph --pretty=format:'%Cred%h -%C(yellow)%d%Creset %s %Cgreen(%cI) %C(bold blue)<%an>%Creset' --abbrev-commit main"
alias mgld="git log --graph --pretty=format:'%Cred%h -%C(yellow)%d%Creset %s %Cgreen(%cI) %C(bold blue)<%an>%Creset' --abbrev-commit develop"
alias mglh="mgl | head"
alias mgm="git merge"
alias mgmd="git merge develop"
alias mgmm="git merge main"
alias mgp="git pull"
alias mgpu="git push"
alias mgr="git reset"
alias mgrhh="git reset --hard HEAD~10"
alias mgrh1="git reset --hard HEAD~1"
alias mgrh2="git reset --hard HEAD~2"
alias mgrh3="git reset --hard HEAD~3"
alias mgrb="git rebase"
alias mgs="git status --short --branch"
alias mgst="git stash"
alias mgt="git tag"

# multipass alias
alias mp="multipass"
alias mps="multipass start"
alias mpst="multipass stop"

# dotnet alias
alias mdr="dotnet run"

# terraform alias
alias mt="terraform"

alias l="exa -lagB --time-style long-iso"
alias ff="fzf"
alias f="fzf --print0 | xargs -0 -o vim"

alias mis="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Applications/iPhone\ Simulator.app/Contents/MacOS/iPhone\ Simulator -SimulateApplication"
alias mis6="open -a \"iOS Simulator\""

# List directory content upon cd
function d {
    builtin cd "$@" && pushd . 1> /dev/null && ls -a
}
alias d-="popd 1> /dev/null"
which Vim 2>&1 >/dev/null && alias vimn="Vim -u NONE -N"

alias ..="d .."

# edit crontab on mac
alias crone="VIM_CRONTAB=true EDITOR=vim crontab -e"

# utility for llama
function lm {
  cd "$(walk "$@")"
}
export LLAMA_EDITOR=vim

mux() {
    tmux new -d -s delete-me && (tmux run-shell ~/.tmux/plugins/tmux-resurrect/scripts/restore.sh && tmux kill-session -t delete-me) &&\
    (for session_window in $(tmux list-windows -a -F '#{session_name}:#{window_index}'); do
        tmux set-window-option -t $session_window automatic-rename on
    done) &&\
    tmux attach || tmux attach
}

# Commit by gemini
function gcommit() {
  diff=$(git diff --staged)
  if [ -z "$diff" ]; then echo "No staged changes."; return 1; fi

  # Generate message and commit
  msg=$(echo "$diff" | gemini "Write a concise Conventional Commit message for this. Output ONLY the message.")
  git commit -m "$msg"
}

# Create PR by gemini
gpr() {
  # 1. Config
  local BASE_BRANCH=${1:-main}
  local CURRENT_BRANCH=$(git branch --show-current)

  # 2. Safety Check
  if [[ "$CURRENT_BRANCH" == "$BASE_BRANCH" ]]; then
    echo "‚ùå Error: You are on the base branch ($BASE_BRANCH). Move to a feature branch."
    return 1
  fi

  # 3. Push to remote (required for 'gh pr create')
  echo "üöÄ Pushing branch to origin..."
  git push -u origin "$CURRENT_BRANCH"

  # 4. Context Gathering
  # We use the commit messages since branching off BASE_BRANCH
  local LOGS=$(git log ${BASE_BRANCH}..HEAD --oneline)
  
  if [[ -z "$LOGS" ]]; then
    echo "‚ùå No new commits found."
    return 1
  fi

  echo "üß† Gemini is drafting the PR description..."

  # 5. Generate Title & Body
  # We ask for a specific format to make parsing easy
  local PROMPT="Analyze these commits and generate a PR title and markdown body. 
Output format:
TITLE: <title>
BODY:
<body>

Commits:
$LOGS"

  local AI_OUTPUT=$(gemini -p "$PROMPT")

  # 6. Parse Output
  local PR_TITLE=$(echo "$AI_OUTPUT" | grep "^TITLE:" | sed 's/^TITLE: //')
  local PR_BODY=$(echo "$AI_OUTPUT" | sed -n '/^BODY:/,$p' | sed '1d')

  # 7. Create PR via GitHub CLI
  echo "üìù Creating PR: $PR_TITLE"
  gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE_BRANCH"
}

# Create MR by gemini (GitLab)
glpr() {
  # 1. Config
  local BASE_BRANCH=${1:-main}
  local CURRENT_BRANCH=$(git branch --show-current)

  # 2. Safety Check
  if [[ "$CURRENT_BRANCH" == "$BASE_BRANCH" ]]; then
    echo "‚ùå Error: You are on the base branch ($BASE_BRANCH). Move to a feature branch."
    return 1
  fi

  # 3. Push to remote (required for 'glab mr create')
  echo "üöÄ Pushing branch to origin..."
  git push -u origin "$CURRENT_BRANCH"

  # 4. Context Gathering
  local LOGS=$(git log ${BASE_BRANCH}..HEAD --oneline)
  
  if [[ -z "$LOGS" ]]; then
    echo "‚ùå No new commits found."
    return 1
  fi

  echo "üß† Gemini is drafting the MR description..."

  # 5. Generate Title & Body
  local PROMPT="Analyze these commits and generate a MR title and markdown body. 
Output format:
TITLE: <title>
BODY:
<body>

Commits:
$LOGS"

  local AI_OUTPUT=$(gemini -p "$PROMPT")

  # 6. Parse Output
  local MR_TITLE=$(echo "$AI_OUTPUT" | grep "^TITLE:" | sed 's/^TITLE: //')
  local MR_BODY=$(echo "$AI_OUTPUT" | sed -n '/^BODY:/,$p' | sed '1d')

  # 7. Create MR via GitLab CLI
  echo "üìù Creating MR: $MR_TITLE"
  glab mr create --title "$MR_TITLE" --description "$MR_BODY" --target-branch "$BASE_BRANCH"
}
